# P7思路

考虑到出错可能在IF级（取指错误）、ID（错误指令）、EX（计算溢出）、Mem（存取异常）级产生，流水线寄存器中应加入错误信号的流水，同时考虑如存取数的溢出错误产生于EX，但应归类于Mem类这样的情况。最终在Mem阶段检查有无错误信号，若有错误信号则取消任何向DM和GRF的写入操作（DMEn置零，RegWriteAddr置零）。

例外：乘除相关指令会产生错误吗？

在Mem阶段若检测到错误信号有效，则将错误信息发送给CP0，通知进入错误处理程序。

* 如何通知进入错误处理？

另外需要考虑中断情况。若产生中断，有以下问题：

* 流水线中哪一级正在执行的指令应被当作是受害指令？
  * 注意中断的受害指令和错误的受害指令不同，错误的受害指令要扔掉，中断的受害指令相当于中断插入在本条指令之前，要将它保存起来以待后续执行。
  * 解决机制：选择EPC存入PC+4还是当前PC。
  * 站在评测系统的角度，我如何插入中断能保证随机性最小？
    * 本次顶层模块加入了宏观PC这一输出，相当于“当前还没有执行完的指令”。
    * 考虑到指令的执行结果实际上会在Mem（sw）和WB（其它寄存器相关）阶段动存储相关元件，由于我们实际上不知道当前指令及其后续/前序指令执行情况，我们应该跟踪Mem阶段的指令地址，这样可以保证当前指令一定没被执行完。
    * 那么我们的异常处理就应该使得Mem级待处理的指令好像没来过，这就需要防止Mem的写入。可以采取同步复位的方式清空IF/ID、ID/EX、EX/Mem、Mem/WB级流水线寄存器，且为了避免错误地写入DM，将DM的写使能也一并作清零处理。对于受害指令前一条，由于已经进WB环节，下一个上升沿可以直接执行完毕，因此不必理会。同时需要改PC的值，让它接下来从异常处理模块读指令。

## 错误检测

### 取指异常

在PC中检查地址正确性（4字节对齐、未越界）

#### 进一步讨论

为何会出现取指异常？

跳转和分支指令可能出现的取值错误。

因此受害指令应该就是犯罪指令，即出错的跳转/分支指令。

#### 再进一步

由于我们需要错误信息和对应指令一同流水，我们可以在ID级计算跳转地址时就检测是否出现越界错误。

而对于未对齐错误，我们应该在IF阶段检查是否不合格，这样可以正确定位受害指令。

### 取数/存数异常

EX阶段结合InstrType检查地址溢出、写入地址不合法

Mem阶段检查写入地址是否对齐？（是否应该提到EX段？考虑除DM外其他元件？）

### 未知指令

在InstrDecoder中检查指令正确性

### 溢出

EX阶段对算术指令检查

需要注意的是实际上乘除模块相关指令并不会造成错误，这可以简化设计。

#### 由于乘除模块不可能出错，对错误的处理至少可以推到Mem级

需要将外部中断信号直接接入错误处理模块，这样才能保证最优先响应中断信号。

#### 最终实现方案

* 在IF阶段检查地址是否合法，对应AdEL
* 在ID阶段检查指令是否可以识别，对应RI
* 在EX阶段检查溢出，根据指令类型对应Ov或AdEL
* 在Mem阶段检查存取数地址对齐情况、存取数地址是否合法，对应AdEL和AdES
* 同时每次检查时都同时检查前一条指令是否为分支/跳转指令，若是的话说明在延迟槽内，需要激活一个信号来证明是分支延迟，同时在提交CP0时激活BD，修改EPC。
  * 或者可以在最终检查时同时检查WB级的指令类型是否为分支/跳转指令即可。

## 受害指令

需要注意受害指令在延迟槽内的情况，这时需要将受害指令指向其之前的分支/跳转指令，否则这会导致处理完之后直接回到延迟槽而非应该跳转的分支指令。

我们可以（而且似乎是应该）选择在Mem级处理异常信号，当一个指令在Mem级出错，但下一条指令在取指阶段出错时，实际上后一条指令会先出错，但是由于我们仅在Mem处理异常信号，其它级异常信号逐级流水，这能保证我们处理到的是最新的错误。

## 主要结构

将P6的CPU打包作为一个整体的CPU模块，且要在其中加入新的CP0（其实好像也可以不加入？）

扩展一个新的Bridge元件，与CPU相连

同时将两个定时器当做外部元件接在Bridge的另一端。

最后将以上几个原件打包封入mips.v

## Bridge

Bridge在P7的设计中只需承担CPU与定时器的通信桥梁功能，因此只需对地址0x0000_7F00-0x0000_7F0B以及0x0000_7F10-0x0000_7F1B两个地址段进行响应，其它地址段要么是CPU内部读写位置，要么是错误地址已经在CPU内部处理完毕。

需要保证送到Bridge的地址均是正确无误的地址。这可以通过这样的机制实现：

* 仅对处于需要处理地址段的地址激活Bridge功能；

* 在CPU内部执行地址对齐检测，然后在Bridge内不予执行地址错误的内容。

* 似乎在给出的定时器代码中只支持对整字的读写，因此不需要考虑lb、lh、sb、sh之类指令操作定时器？

相应的，我们需要对CPU增加接口。实际上考虑教程给出的方案，我们可能不需要PrBE信号，因为我们已经规定必须以整字方式访问定时器寄存器。

## CP0

CP0有很多寄存器，我们只需要实现CP0的12号寄存器SR，13号寄存器Cause，14号寄存器EPC，15号寄存器PRId即可。考虑用一个CP0的Bridge统一解码CP0类指令，然后给CP0设置一个写使能，由CP0Bridge向CP0发送数据时带上写使能信号以通知CP0有数据传入。

中断处理时需要屏蔽中断，因此需要将EXL置位，Bridge处需进行处理。结束处理时EXL要清零。

## 关于mtc0和mfc0

需要注意mfc0需要读取rd的值，写入rt寄存器；mtc0需要读rt和rd，这与其它指令大不同，但得益于我们的AT计算模块，我们可以简单地把RAddr和WAddr进行相应设置即可。

